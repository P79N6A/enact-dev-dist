var
	path = require('path'),
	fs = require('graceful-fs'),
	exists = require('path-exists').sync,
	glob = require('glob'),
	webpack = parentRequire('webpack');

// Recursively attempt to find a module up a parent-chain.
function parentRequire(request) {
	var parent = module.parent;
	while(parent) {
		try {
			return parent.require(request);
		} catch(e) {
			parent = parent.parent;
		}
	}
}

function packageName(file) {
	try {
		return JSON.parse(fs.readFileSync(file, {encoding:'utf8'})).name || '';
	} catch(e) {
		return '';
	}
}

function ilibSearch(dir) {
	var ilibPath;
	while(dir!=='/' && dir!=='\\' && dir!=='.' && dir!=='' && !ilibPath) {
		var full = path.join(dir, 'node_modules/@enact/i18n/ilib');
		if(exists(full)) {
			ilibPath = path.relative(process.cwd(), full);
		} else {
			dir = path.dirname(dir);
		}
	}
	return ilibPath;
}

// Determine if it's a NodeJS output filesystem or if it's a foreign/virtual one.
function isNodeOutputFS(compiler) {
	return (compiler.outputFileSystem
			&& compiler.outputFileSystem.constructor
			&& compiler.outputFileSystem.constructor.name
			&& compiler.outputFileSystem.constructor.name === 'NodeOutputFileSystem');
}

// Normalize a filepath to be relative to the webpack context, using forward-slashes, and
// replace each '..' with '_', keeping in line with the file-loader and other webpack standards.
function transformPath(context, file) {
	return path.relative(context, file).replace(/\\/g, '/').replace(/\.\.(\/)?/g, "_$1");
}

// Read a manifest (creating a new one dynamically as applicable) and emit it,
// returning its contents.
function readManifest(compilation, manifest, opts) {
	var data;
	var files = [];
	if(typeof manifest === 'string') {
		if(exists(manifest)) {
			manifest = fs.realpathSync(manifest);
			data = fs.readFileSync(manifest, {encoding:'utf8'});
			if(data) {
				files = JSON.parse(data).files || files;
			}
		}
		emitAsset(compilation, transformPath(opts.context, manifest), data);
	} else {
		files = manifest.value || files;
		data = JSON.stringify({files:files}, null, '\t');
		emitAsset(compilation, transformPath(opts.context, manifest.generate), data);
	}
	
	return files;
}

// Read each manifest and process their contents.
function handleBundles(compilation, manifests, opts, callback) {
	if(manifests.length === 0) {
		callback();
	} else {
		var manifest = manifests.shift();
		try {
			var files = readManifest(compilation, manifest, opts);
			if(exists(manifest) || opts.create) {
				var root = fs.realpathSync(path.dirname(manifest));
				handleManifestFiles(compilation, root, files, opts, function() {
					handleBundles(compilation, manifests, opts, callback);
				});
			} else {
				handleBundles(compilation, manifests, opts, callback);
			}
		} catch(e) {
			compilation.errors.push(new Error('iLibPlugin: Unable to read localization manifest at '
					+ manifest));
			handleBundles(compilation, manifests, opts, callback);
		}
	}
}

// Read and emit all the assets in a particular manifest.
function handleManifestFiles(compilation, root, files, opts, callback) {
	if(files.length === 0) {
		callback();
	} else {
		var outfile = path.join(root, files.shift());
		if(shouldEmit(compilation.compiler, outfile, opts.cache)) {
			fs.readFile(outfile, function(err, data) {
				if(err) {
					compilation.errors.push(err);
				} else {
					emitAsset(compilation, transformPath(opts.context, outfile), data)
				}
				handleManifestFiles(compilation, root, files, opts, callback);
			});
		} else {
			handleManifestFiles(compilation, root, files, opts, callback);
		}
	}
}

// Determine if the output file exists and if its newer to determine if it should be emitted.
function shouldEmit(compiler, file, cache) {
	if(isNodeOutputFS(compiler)) {
		try {
			var src = fs.statSync(file);
			var dest = fs.statSync(path.join(compiler.options.output.path, transformPath(compiler.options.context, file)));
			return src.isDirectory() || src.mtime.getTime()>dest.mtime.getTime() || !cache;
		} catch(e) {
			return true;
		}
	} else {
		return true;
	}
}

// Add a given asset's data to the compilation array in a webpack-compatible source object.
function emitAsset(compilation, name, data) {
	compilation.assets[name] = {
		size: function() { return data.length; },
		source: function() { return data; },
		updateHash: function(hash) { return hash.update(data); },
		map: function() { return null; }
	};
}


function ILibPlugin(options) {
	this.options = options || {};
	this.options.ilib = this.options.ilib || process.env.ILIB_BASE_PATH;
	// Temporary backwards compatibility until the build system is updated for ILIB_BASE_PATH.
	if(process.env.ILIB_LOCALE_PATH) {
		this.options.ilib = path.dirname(process.env.ILIB_LOCALE_PATH);
	}
	if(typeof this.options.ilib === 'undefined') {
		try {
			var pkgName = packageName('./package.json');
			if(pkgName.indexOf('@enact') === 0) {
				this.options.resources = false;
			}
			if(pkgName === '@enact/i18n') {
				this.options.ilib = 'ilib';
			} else {
				this.options.ilib = ilibSearch(process.cwd());
			}
		} catch(e) {
			console.error('ERROR: iLib locale not detected. Please ensure @enact/i18n is installed.');
			process.exit(1);
		}
	} else {
		this.options.emit = false;
	}
	if(typeof this.options.resources === 'undefined') {
		this.options.resources = 'resources';
	}
	this.options.bundles = this.options.bundles || [];
	this.options.cache = (typeof this.options.cache !== 'boolean' || this.options.cache);
	this.options.create = (typeof this.options.create !== 'boolean' || this.options.create);
	this.options.emit = (typeof this.options.emit !== 'boolean' || this.options.emit);
}

ILibPlugin.prototype.apply = function(compiler) {
	var opts = this.options;
	var manifests = opts.bundles.slice(0);
	var created = [];
	opts.context = compiler.options.context;

	if(opts.ilib) {
		// Resolve an accurate basepath for iLib.
		var basePath;
		if(path.isAbsolute(opts.ilib)) {
			opts.emit = false;
			basePath = JSON.stringify(opts.ilib);
		} else {
			if(!exists(opts.ilib)) {
				opts.emit = false;
			} else {
				opts.ilib = fs.realpathSync(opts.ilib);
			}
			basePath = '__webpack_require__.p + ' + JSON.stringify(transformPath(opts.context, opts.ilib));
		}

		// Rewrite the iLib global constants to  specific values corresponding to the build.
		if(webpack && webpack.DefinePlugin) {
			compiler.apply(new webpack.DefinePlugin({
				ILIB_BASE_PATH: basePath,
				ILIB_RESOURCES_PATH: '__webpack_require__.p + ' + JSON.stringify(transformPath(opts.context, opts.resources || 'resources')),
				ILIB_CACHE_ID: '__webpack_require__.ilib_cache_id'
			}));
		}
		// Add a unique ID value to the webpack require-function, so that the value is correctly updated,
		// even when hot-reloading and serving.
		compiler.plugin('compilation', function(compilation) {
			compilation.mainTemplate.plugin("require-extensions", function(source, chunk, hash) {
				var buf = [source];
				buf.push("");
				buf.push(this.requireFn + '.ilib_cache_id = ' + JSON.stringify('' + new Date().getTime()) + ';');
				return this.asString(buf);
			});
		});

		// Prepare manifest list for usage.
		// Missing files will created if needed otherwise scanned.
		if(opts.emit) {
			manifests.unshift(path.join(opts.ilib, 'locale', 'ilibmanifest.json'));
		}
		if(opts.resources) {
			manifests.push(path.join(opts.resources, 'ilibmanifest.json'));
		}
		for(var i=0; i<manifests.length; i++) {
			if(!exists(manifests[i])) {
				var dir = path.dirname(manifests[i]);
				var files = glob.sync('./**/!(appinfo).json', {nodir:true, cwd:dir});
				for(var k=0; k<files.length; k++) {
					files[k] = files[k].replace(/^\.\//, '');
				}
				if(opts.create) {
					if(!exists(dir)) {
						fs.mkdirSync(dir);
					}
					fs.writeFileSync(manifests[i], JSON.stringify({files:files}, null, '\t'), {encoding:'utf8'});
					created.push(manifests[i]);
				} else {
					manifests[i] = {generate:manifests[i], value:files};
				}
			}
		}

		// Emit all bundles as applicable.
		compiler.plugin('emit', function(compilation, callback) {
			for(var j=0; j<created.length; j++) {
				compilation.warnings.push(new Error('iLibPlugin: Localization resource manifest not found. Created '
						+ created[j] + ' to prevent future errors.'));
			}
			manifests = compilation.applyPluginsWaterfall('ilib-manifest-list', manifests);
			handleBundles(compilation, manifests, opts, callback);
		});
	}
};

module.exports = ILibPlugin;
