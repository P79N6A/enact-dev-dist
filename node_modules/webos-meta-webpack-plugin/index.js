var
	path = require('path'),
	fs = require('fs'),
	glob = require('glob'),
	exists = require('path-exists').sync;

// List of asset-pointing appinfo properties.
var props = [
	'icon',
	'largeIcon',
	'miniicon',
	'smallicon',
	'splashicon',
	'splashBackground',
	'bgImage'
];
// Mapping of absolute asset file paths to their relative distribution output.
// This allows us to avoid having multiple of the same files for locales that
// share assets.
var assetPathCache = {};

function readAppInfo(file) {
	// Read and parse appinfo.json file if it exists.
	if(exists(file)) {
		try {
			var meta = JSON.parse(fs.readFileSync(file, {encoding: 'utf8'}));
			return meta;
		} catch(e) {
			console.log('ERROR: unable to read/parse appinfo.json at ' + file);
		}
	}
}

function rootAppInfo(context, specific) {
	// The accepted root locations to search for the appinfo.json and its relative 
	// assets are project root or ./webos-meta.
	var root = [
		context,
		path.join(context, './webos-meta')
	];
	// If a specific path is requested, prepend it to the search list
	if(specific) {
		if(path.isAbsolute(specific)) {
			root.unshift(specific);
		} else {
			root.unshift(path.join(context, specific));
		}
	}
	// Check each search location, and if found, return the data and path it was found at.
	var meta, dir;
	for(var i=0; i<root.length; i++) {
		meta = readAppInfo(path.join(root[i], 'appinfo.json'));
		if(meta) {
			return {path:root[i], obj:meta} 
		}
	}
}

function addMetaAssets(metaDir, outDir, appinfo, assets) {
	// For each appinfo.json property that contains a webos meta asset, resolve that asset,
	// and add its data to the compilation assets array.
	for(var i=0; i<props.length; i++) {
		var p = props[i];
		if(appinfo[p]) {
			var abs = path.resolve(path.join(metaDir, appinfo[p]));
			if(assetPathCache[abs]) {
				appinfo[p] = path.relative(outDir, assetPathCache[abs]);
			} else {
				assetPathCache[abs] = path.join(outDir, appinfo[p]);
			}
			if(!assets[assetPathCache[abs]]) {
				try {
					var data = fs.readFileSync(path.join(metaDir, appinfo[p]))
					emitAsset(assetPathCache[abs], assets, data);
				} catch(e) {
					console.log('Unable to read/emit appinfo asset: ' + file);
				}
			}
		}
	}
}

function emitAsset(name, assets, data) {
	// Add a given asset's data to the compilation array in a webpack-compatible source object.
	assets[name] = {
		size: function() { return data.length; },
		source: function() { return data; },
		updateHash: function(hash) { return hash.update(data); },
		map: function() { return null; }
	};
}

function WebOSMetaPlugin(options) {
	this.options = options || {};
}

module.exports = WebOSMetaPlugin;
WebOSMetaPlugin.prototype.apply = function(compiler) {
	var scan = this.options.path;
	var context = this.options.context || compiler.options.context;

	compiler.plugin('emit', function(compilation, callback) {
		// Add the root appinfo.json as well as its relative assets to the compilation.
		var meta = rootAppInfo(context, scan);
		if(meta) {
			addMetaAssets(meta.path, '', meta.obj, compilation.assets);
			emitAsset('appinfo.json', compilation.assets, new Buffer(JSON.stringify(meta.obj, null, '\t')));
		}

		// Scan for all localized appinfo.json files in the "resources" directory.
		var loc = glob.sync('resources/**/appinfo.json', {
			cwd: context,
			nodir: true
		});
		// Add each locale-specific appinfo.json and its relative assets to the compilation.
		var locFile, locMeta;
		for(var i=0; i<loc.length; i++) {
			locFile = path.join(context, loc[i]);
			locMeta = readAppInfo(locFile);
			if(locMeta) {
				addMetaAssets(path.dirname(locFile), path.dirname(loc[i]), locMeta, compilation.assets);
				emitAsset(loc[i], compilation.assets, new Buffer(JSON.stringify(locMeta, null, '\t')));
			}
		}
		callback();
	});
	compiler.plugin('compilation', function(compilation) {
		compilation.plugin('html-webpack-plugin-before-html-generation', function(params, callback) {
			var appinfo = rootAppInfo(context, scan);
			if(appinfo) {
				// When no explicit HTML document title is provided, automically use the root appinfo's title value.
				if(appinfo.obj.title && (!params.plugin.options.title || params.plugin.options.title==='Webpack App')) {
					params.plugin.options.title = appinfo.obj.title;
				}
			}
			callback();
		});
	});
};
