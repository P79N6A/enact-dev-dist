var path = require('path');

function readAppInfo(fs, search, callback) {
	if(search.length==0) {
		callback();
	} else {
		var dir = search.shift();
		var file = path.join(dir, 'appinfo.json');
		fs.readFile(file, function(err, data) {
			if(err) {
				readAppInfo(fs, search, callback);
			} else {
				var obj;
				try {
					obj = JSON.parse(data.toString('utf-8'));
				} catch(e) {
					console.log('ERROR: unable to parse appinfo.json at ' + file);
					obj = undefined;
				}
				callback(dir, obj);
			}
		})
	}
}

function addMetaAssets(fs, dir, appinfo, props, assets, callback) {
	if(props.length===0) {
		callback();
	} else {
		var prop = props.shift();
		if(appinfo[prop]) {
			var file = path.join(dir, appinfo[prop]);
			fs.readFile(file, function(err, data) {
				if(err) {
					console.log('Unable to read/emit appinfo asset: ' + file);
				} else {
					appinfo[prop] = appinfo[prop].replace(/\.\.(\/)?/g, "_$1");
					assets[appinfo[prop]] = {
						size: function() { return data.length; },
						source: function() { return data; },
						updateHash: function(hash) { return hash.update(data); },
						map: function() { return null; }
					}
				}
				addMetaAssets(fs, dir, appinfo, props, assets, callback);
			});
		} else {
			addMetaAssets(fs, dir, appinfo, props, assets, callback);
		}
	}
}

function WebOSMetaPlugin(options) {
	this.options = options || {};
}

module.exports = WebOSMetaPlugin;
WebOSMetaPlugin.prototype.apply = function(compiler) {
	var scanDirs = ['.', './webos-meta'];
	if(this.options.path) {
		scanDirs.unshift(this.options.path)
	}

	compiler.plugin('emit', function(compilation, callback) {
		var fs = compilation.inputFileSystem;
		readAppInfo(fs, scanDirs, function(dir, appinfo) {
			if(!appinfo) {
				callback();
			} else {
				var props = [
					'icon',
					'largeIcon',
					'miniicon',
					'smallicon',
					'splashicon',
					'splashBackground',
					'bgImage'
				];
				addMetaAssets(fs, dir, appinfo, props, compilation.assets, function() {
					var aiBuffer = new Buffer(JSON.stringify(appinfo, null, '\t'));
					compilation.assets['appinfo.json'] = {
						size: function() { return aiBuffer.length; },
						source: function() { return aiBuffer; },
						updateHash: function(hash) { return hash.update(aiBuffer); },
						map: function() { return null; }
					};
					callback();
				})
			}
		});
	});
	compiler.plugin('compilation', function(compilation) {
		compilation.plugin('html-webpack-plugin-before-html-generation', function(params, callback) {
			var fs = compilation.inputFileSystem;
			readAppInfo(fs, scanDirs, function(dir, appinfo) {
				if(appinfo) {
					if(appinfo.title && (!params.plugin.options.title || params.plugin.options.title==='Webpack App')) {
						params.plugin.options.title = appinfo.title;
					}
				}
				callback();
			});
		});
	});
};
